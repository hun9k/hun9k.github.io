{"/docs/go/code-generator/":{"data":{"":"代码生成的主要思路：\n直接基于代码模板生成，text/template 基于已有结构生成，go/ast + text/template 代码格式化","goast与-reflect的差别#\u003ccode\u003ego/ast\u003c/code\u003e与 \u003ccode\u003ereflect\u003c/code\u003e的差别":"多说一句，要分清go/ast抽象语法树与reflect反射的差别：\ngo/ast抽象语法树，基于Go源码（字符串）获取信息 reflect反射，基于Go程序（内存结构）获取信息 因此，代码生成通常基于Go源码来生成，使用go/ast相关包多些。","基于代码模板生成#基于代码模板生成":"通常来说，最简单的生成代码，就是那种固定的代码，例如，生成某个资源的Rest路由，例如：\nrouter := gin.Default() group := router.Group(\"v1\").Group(\"articles\") group.POST(\"\", articles.Post) // 创建一个资源 group.DELETE(\":id\", articles.DeleteId) // 删除一个资源 group.PUT(\":id\", articles.PutId) // 更新一个资源 group.GET(\":id\", articles.GetId) // 获取一个资源 group.GET(\"\", articles.Get) // 获取多个资源 代码中，只有articles资源名称部分是不同的，因此我们仅需要更改articles部分即可。\n那么就可以创建一个模板文件，使用Go标准库 text/template：\ntmplRouter = `router := gin.Default() group := router.Group(\"{{.RouterVersion}}\").Group(\"{{.ResourceName}}\") group.POST(\"\", articles.Post) // 创建一个资源 group.DELETE(\":id\", articles.DeleteId) // 删除一个资源 group.PUT(\":id\", articles.PutId) // 更新一个资源 group.GET(\":id\", articles.GetId) // 获取一个资源 group.GET(\"\", articles.Get) // 获取多个资源 ` 利用这个模板，替换必要的版本和资源名部分，就可以生成Go代码，后边写入到articles.go文件即可。","基于已有结构生成#基于已有结构生成":"有的时候，我们需要根据以后的代码结构，来生成。例如，基于GORM的模型定义，生成相关的业务逻辑代码，此时往往需要知道模型中有哪些字段，然后根据字段类型或其他信息，分别处理，例如：\n// schemas/articles.go type Articles struct { // 自定义字段 Subject string `gorm:\"\" json:\"subject\"` Summary string `gorm:\"\" json:\"summary\"` Content string `gorm:\"\" json:\"content\"` Likes int `gorm:\"\" json:\"likes\"` IsPublished bool `gorm:\"\" json:\"is_published\"` Birthday time.Time `gorm:\"\" json:\"birthday\"` // 嵌入基础字段，ID，CreatedAt，UpdatedAt, DeletedAt gorm.Model } 以上模型是我们手动定义的，接下来将根据这个模型定义生成基础的CRUD代码。\n第一步，就需要知道到底有哪些字段。这就属于动态的结构，因为我们不知道，到底有哪些字段。\n那如何才能知道这个模型的结构呢？就需要Go源码分析工具。Go标准库的**go/ast**及相关的包，可以完成Go源码的分析任务，相关的包：\ngo/parser，解析器实现了Go源文件的解析器 go/ast，声明用于表示Go包的语法树的类型 go/token，包含了表示Go语言的词法token，以及对token的基本操作的常量 go/types，声明数据类型并实现Go包的类型检查算法 go/format，实现了Go源代码的标准格式 go/doc，从AST中提取源代码文档 当然还有其他包，可以从https://pkg.go.dev/go 中查看。\n快速演示，获取模型定义中，有哪些字段：\n// 解析模型结构.go文件 fset := token.NewFileSet() filename := filepath.Join(\"schemas/articles.go\") file, err := parser.ParseFile(fset, filename, nil, parser.ParseComments) if err != nil { return nil, err } // 找到模型定义的结构体 var schemaStruct *ast.StructType ast.Inspect(file, func(n ast.Node) bool { switch x := n.(type) { case *ast.TypeSpec: schemaStruct = x.Type.(*ast.StructType) return false } return true }) if schemaStruct == nil { return nil, errors.New(\"schema struct not found\") } // 遍历全部字段 for _, field := range schemaStruct.Fields.List { switch t := field.Type.(type) { case *ast.Ident: // 常规类型，例如 string, int, bool fmt.Println(t.Name) case *ast.SelectorExpr: // 带有选择器的类型，例如 time.Time, gorm.Model fmt.Println(t.X.(*ast.Ident).Name, t.Sel.Name) } } 示例代码到此，就可以确定有哪些需要处理的字段。进而就可以根据字段，做后续的代码生成了。后续的工作，就变为了基于代码模板生成代码了。","格式化代码#格式化代码":"方案：\ngo/format包，将代码格式化完毕后，写入.go文件 go fmt工具，代码写入.go文件后，执行go fmt命令进行格式化 选择那种都行，推荐第一种，这样可以仅进行一次文件操作。否则，写入和go fmt需要两次文件操作。"},"title":"生成Go代码"},"/docs/vscode/snippets/":{"data":{"":"VSCode的代码片段（Snippets），是指预设好代码，通过简短提示，快速生成大量代码的功能。例如，最典型的错误判定代码：\nif err != nil { return err } if err == nil { // your code } 编写Go代码时，几乎每个函数中都要出现好几次。代码片段的目的就是让这种常用代码快速实现。键入iferr后：\n// iferr if err != nil { return nil, err }","内置go语言snippets#内置Go语言Snippets":"稍微注意下，是VSCode的Go扩展（Go for Visual Studio Code）内置的，不是VSCode内置的：\n$HOME\\.vscode\\extensions\\golang.go-\\snippets\\go.json{ \".source.go\": { \"single import\": { \"prefix\": \"im\", \"body\": \"import \\\"${1:package}\\\"\" }, \"multiple imports\": { \"prefix\": \"ims\", \"body\": \"import (\\n\\t\\\"${1:package}\\\"\\n)\" }, \"single constant\": { \"prefix\": \"co\", \"body\": \"const ${1:name} = ${2:value}\" }, \"multiple constants\": { \"prefix\": \"cos\", \"body\": \"const (\\n\\t${1:name} = ${2:value}\\n)\" }, \"type function declaration\": { \"prefix\": \"tyf\",\"body\": \"type ${1:name} func($3) $4\" }, \"type interface declaration\": { \"prefix\": \"tyi\", \"body\": \"type ${1:name} interface {\\n\\t$0\\n}\" }, \"type struct declaration\": { \"prefix\": \"tys\", \"body\": \"type ${1:name} struct {\\n\\t$0\\n}\" }, \"package main and main function\": { \"prefix\": \"pkgm\", \"body\": \"package main\\n\\nfunc main() {\\n\\t$0\\n}\" }, \"function declaration\": { \"prefix\": \"func\", \"body\": \"func $1($2) $3 {\\n\\t$0\\n}\" }, \"single variable\": { \"prefix\": \"var\", \"body\": \"var ${1:name} ${2:type}\" }, \"multiple variables\": { \"prefix\": \"vars\", \"body\": \"var (\\n\\t${1:name} ${2:type}\\n)\" }, \"switch statement\": { \"prefix\": \"switch\", \"body\": \"switch ${1:expression} {\\ncase ${2:condition}:\\n\\t$0\\n}\" }, \"select statement\": { \"prefix\": \"sel\", \"body\": \"select {\\ncase ${1:condition}:\\n\\t$0\\n}\" }, \"case clause\": { \"prefix\": \"cs\", \"body\": \"case ${1:condition}:$0\" }, \"for statement\": { \"prefix\": \"for\", \"body\": \"for ${1:i} := ${2:0}; $1 \u003c ${3:count}; $1${4:++} {\\n\\t$0\\n}\" }, \"for range statement\": { \"prefix\": \"forr\", \"body\": \"for ${1:_}, ${2:v} := range ${3:v} {\\n\\t$0\\n}\" }, \"channel declaration\": { \"prefix\": \"ch\", \"body\": \"chan ${1:type}\" }, \"map declaration\": { \"prefix\": \"map\", \"body\": \"map[${1:type}]${2:type}\" }, \"empty interface\": { \"prefix\": \"in\", \"body\": \"interface{}\" }, \"if statement\": { \"prefix\": \"if\", \"body\": \"if ${1:condition} {\\n\\t$0\\n}\" }, \"else branch\": { \"prefix\": \"el\", \"body\": \"else {\\n\\t$0\\n}\" }, \"if else statement\": { \"prefix\": \"ie\", \"body\": \"if ${1:condition} {\\n\\t$2\\n} else {\\n\\t$0\\n}\" }, \"if err != nil\": { \"prefix\": \"iferr\", \"body\": \"if err != nil {\\n\\t${1:return ${2:nil, }${3:err}}\\n}\" }, \"fmt.Println\": { \"prefix\": \"fp\", \"body\": \"fmt.Println(\\\"$1\\\")\" }, \"fmt.Printf\": { \"prefix\": \"ff\", \"body\": \"fmt.Printf(\\\"$1\\\", ${2:var})\" }, \"log.Println\": { \"prefix\": \"lp\", \"body\": \"log.Println(\\\"$1\\\")\" }, \"log.Printf\": { \"prefix\": \"lf\", \"body\": \"log.Printf(\\\"$1\\\", ${2:var})\" }, \"log variable content\": { \"prefix\": \"lv\", \"body\": \"log.Printf(\\\"${1:var}: %#+v\\\\\\\\n\\\", ${1:var})\" }, \"t.Log\": { \"prefix\": \"tl\", \"body\": \"t.Log(\\\"$1\\\")\" }, \"t.Logf\": { \"prefix\": \"tlf\", \"body\": \"t.Logf(\\\"$1\\\", ${2:var})\" }, \"t.Logf variable content\": { \"prefix\": \"tlv\", \"body\": \"t.Logf(\\\"${1:var}: %#+v\\\\\\\\n\\\", ${1:var})\" }, \"make(...)\": { \"prefix\": \"make\", \"body\": \"make(${1:type}, ${2:0})\" }, \"new(...)\": { \"prefix\": \"new\", \"body\": \"new(${1:type})\" }, \"panic(...)\": { \"prefix\": \"pn\", \"body\": \"panic(\\\"$0\\\")\", \"description\": \"Snippet for panic\" }, \"http ResponseWriter *Request\": { \"prefix\": \"wr\", \"body\": \"${1:w} http.ResponseWriter, ${2:r} *http.Request\" }, \"http.HandleFunc\": { \"prefix\": \"hf\", \"body\": \"${1:http}.HandleFunc(\\\"${2:/}\\\", ${3:handler})\" }, \"http handler declaration\": { \"prefix\": \"hand\", \"body\": \"func $1(${2:w} http.ResponseWriter, ${3:r} *http.Request) {\\n\\t$0\\n}\" }, \"http.Redirect\": { \"prefix\": \"rd\", \"body\": \"http.Redirect(${1:w}, ${2:r}, \\\"${3:/}\\\", ${4:http.StatusFound})\" }, \"http.Error\": { \"prefix\": \"herr\", \"body\": \"http.Error(${1:w}, ${2:err}.Error(), ${3:http.StatusInternalServerError})\" }, \"http.ListenAndServe\": { \"prefix\": \"las\", \"body\": \"http.ListenAndServe(\\\"${1::8080}\\\", ${2:nil})\" }, \"http.Serve\": { \"prefix\": \"sv\", \"body\": \"http.Serve(\\\"${1::8080}\\\", ${2:nil})\" }, \"goroutine anonymous function\": { \"prefix\": \"go\", \"body\": \"go func($1) {\\n\\t$0\\n}($2)\" }, \"goroutine function\": { \"prefix\": \"gf\", \"body\": \"go ${1:func}($0)\" }, \"defer statement\": { \"prefix\": \"df\", \"body\": \"defer ${1:func}($0)\" }, \"test function\": { \"prefix\": \"tf\", \"body\": \"func Test$1(t *testing.T) {\\n\\t$0\\n}\" }, \"test main\": { \"prefix\": \"tm\", \"body\": \"func TestMain(m *testing.M) {\\n\\t$1\\n\\n\\tos.Exit(m.Run())\\n}\" }, \"benchmark function\": { \"prefix\": \"bf\", \"body\": \"func Benchmark$1(b *testing.B) {\\n\\tfor ${2:i} := 0; ${2:i} \u003c b.N; ${2:i}++ {\\n\\t\\t$0\\n\\t}\\n}\" }, \"example function\": { \"prefix\": \"ef\", \"body\": \"func Example$1() {\\n\\t$2\\n\\t//Output:\\n\\t$3\\n}\" }, \"table driven test\": { \"prefix\": \"tdt\", \"body\": \"func Test$1(t *testing.T) {\\n\\ttestCases := []struct {\\n\\t\\tdesc\\tstring\\n\\t\\t$2\\n\\t}{\\n\\t\\t{\\n\\t\\t\\tdesc: \\\"$3\\\",\\n\\t\\t\\t$4\\n\\t\\t},\\n\\t}\\n\\tfor _, tC := range testCases {\\n\\t\\tt.Run(tC.desc, func(t *testing.T) {\\n\\t\\t\\t$0\\n\\t\\t})\\n\\t}\\n}\" }, \"init function\": { \"prefix\": \"finit\", \"body\": \"func init() {\\n\\t$1\\n}\" }, \"main function\": { \"prefix\": \"fmain\", \"body\": \"func main() {\\n\\t$1\\n}\" }, \"method declaration\": { \"prefix\": \"meth\", \"body\": \"func (${1:receiver} ${2:type}) ${3:method}($4) $5 {\\n\\t$0\\n}\" }, \"hello world web app\": { \"prefix\": \"helloweb\", \"body\": \"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"net/http\\\"\\n\\t\\\"time\\\"\\n)\\n\\nfunc greet(w http.ResponseWriter, r *http.Request) {\\n\\tfmt.Fprintf(w, \\\"Hello World! %s\\\", time.Now())\\n}\\n\\nfunc main() {\\n\\thttp.HandleFunc(\\\"/\\\", greet)\\n\\thttp.ListenAndServe(\\\":8080\\\", nil)\\n}\" }, \"sort implementation\": { \"prefix\": \"sort\", \"body\": \"type ${1:SortBy} []${2:Type}\\n\\nfunc (a $1) Len() int { return len(a) }\\nfunc (a $1) Swap(i, j int) { a[i], a[j] = a[j], a[i] }\\nfunc (a $1) Less(i, j int) bool { ${3:return a[i] \u003c a[j]} }\" } } } 配置中：\nprefix，输入的前缀 body，生成的代码片段","自定义snippets#自定义Snippets":"除了扩展预定义的，也可以自定义，VSCode菜单：\nFile \u003e Preferences \u003e Configure Snippets // 文件 \u003e 首选项 \u003e 配置代码片段 可以为当前项目和Go全局创建自定义的Snippets配置文件："},"title":"代码片段"}}